\section{Conclusion}
\label{conclusion}

The hardest part for us in this course project is trying to understand how the $\lambdaJ$ works. Since the limited page number, the authors only list the necessary semantics and a small part of property proof, eliminating most detailed explanation. The only resource we can find is a presentation video, a github project with thousands of lines of source codes besides this page. We went through several days' heated discussion before we finally get to understand how $\lambdaJ$ rule out the cases of infinite recursion and what \textbf{rep} is designed for. Another non-trivial task is to run the existing codes successfully and know how it works roughly inside.

The most important thing we have learned from this project, is how to design a new programming language for a specific goal, and what we should deal with as it may introduce extra problems. For example, $\lambdaJ$ syntax leads to infinite recursive calls via symbolic expression, so it provides complicated static semantic to constrain the type checking. Also, since all is based on {\ensuremath{\lambda}}-calculus, it makes us understand the power of this simple language deeper. It's also a good chance for us to look back to the teaching materials in previous courses. All these help us to understand types and programming language better.