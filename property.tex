\section{Properties}
\label{property}

 \begin{lemma}
     $\mathrm{(Concrete Function)}$. if $\upsilon$ is a value of type $\tau_1\rightarrow\tau_2$, then $\upsilon= \lambda x:\tau_1.e$, where e has type $\tau_2$.
    \end{lemma}
 \begin{proof}
     According to the $\lambdaJ$ syntax, we can get Lemma 1 immediately.
    \end{proof}
 
 \begin{theorem}
     $\mathrm{(Progress).}$ Suppose $e$ is a closed, well-typed expression. Then $e$ is either a value $\upsilon$ or there is some $e'$ such that $\vdash\left\langle\Sigma, \Delta, e\right\rangle\rightarrow\left\langle\Sigma',\Delta',e'\right\rangle$.
 \end{theorem}   
    \begin{proof}
        According to the dynamic demantics \ref{dynamic-sem-lambdaj} and static semantics \ref{static-sem-lambdaj} of $\lambdaJ$, we will proof that any $\lambdaJ$ program holds the \emph{progress} property by structral induction over the syntax of $\lambdaJ$. According to Figure \ref{lambdaj-syntax}, there are nine kinds of expressions including the value expression $\upsilon$. Next we discuss each of them respectively.
        \begin{itemize}
            \item For the value expression $\upsilon$, according to the definition we can conclude that it holds the property immediately.
            \item For the expression $e_1~(op)~e_2$, according to the hyposthesis, we know that sub-expression $e_1$ and $e_2$ are both closed and well-typed expressions. Thus if $e_1$ is not a value, according to E-OP1, there must be a expression $e'_1$ such that $e_1\rightarrow e'_1$. Therefore the expression $e_1~(op)~e_2$ can be reduced to $e'_1~(op)~e_2$, and the same as if the $e_1$ is already a value but $e_2$ is not according to E-OP2. While if both $e_1$ and $e_2$ are values, we know that $e_1~(op)~e_2$ is a value as well. Let $c = e_1~(op)~e_2$, according to E-OP, $\vdash\left\langle\Sigma, \Delta, e_1~(op)~e_2 \right\rangle\rightarrow\left\langle\Sigma',\Delta',c \right\rangle$. Hence, we can conclude that expression $e_1~(op)~e_2$ holds the \emph{progress} property.
            \item For the expression $\textbf{if}~e_1~\textbf{then}~e_t~\textbf{else}~e_f$, the conditional expression $e_1$ is a either a \textbf{concrete} expression or a \textbf{symbolic} expression. If expression $e_1$ is \textbf{concrete} and not a value, according to E-COND, there must be an expression $e'_1$ such that $\vdash\left\langle\Sigma, \Delta, \textbf{if}~e_1~\textbf{then}~e_t~\textbf{else}~e_f \right\rangle\rightarrow\left\langle\Sigma',\Delta',\textbf{if}~e'_1~\textbf{then}~e_t~\textbf{else}~e_f \right\rangle$.  Similarly, if expression $e_1$ is a \textbf{concrete} value, it must be \textbf{true} or \textbf{false}. According to E-CONDTRUE and E-CONDFALSE, $\textbf{if}~e_1~\textbf{then}~e_t~\textbf{else}~e_f$ can be reduced as well. On the other hand, if the expression $e_1$ is \textbf{symbolic}, according to E-CONDSYMT and E-CONDSYMF, it holds the \emph{progress} property.
            \item For the expression $e_1~e_2$, if the sub-expression $e_1$ or $e_2$ is not a value, similar as the expression $e_1~(op)~e_2$, according to E-APP1 and E-APP2, it can be at least reduce one step and evetually both $e_1$ and $e_2$ are values. Then according to the previous \textbf{Concrete Function Lemma}, $e_1~e_2$ must be the form as $\lambda x:e.\upsilon$, according to E-APPLAMBDA, it holds the property immediately.
            \item For the expression $\textbf{defer}~x:\tau\{e\}~\textbf{default}~\upsilon_d$, if sub-expression $e$ is not a value, by the induction hypothesis, there must be an expression $e' $ such that $\vdash\left\langle\Sigma, \Delta, e\right\rangle\rightarrow\left\langle\Sigma',\Delta',e'\right\rangle$, then by E-DEFERCONSTRAINT, the expression can perform a reduction $\vdash\left\langle\Sigma, \Delta, \textbf{defer}~x: \tau\{e\}~\textbf{default}~\upsilon_d \right\rangle\rightarrow\left\langle\Sigma',\Delta',\textbf{defer}~x:\tau\{e'\}~\textbf{default}~\upsilon_d\right\rangle$. In addition, if sub-expression $e$ is a value, according to static semantics, it must be some concrete value $v_c$, then according to E-DEFER, a fresh variable named $x'$ will be generated and a new defaut condition will be added to the $\Delta$ environment, which indicates that the expression \textbf{defer}  is progressive.
            \item For the expression $\textbf{assert}~e$, similar as expression of $\textbf{defer}~x:\tau\{e\}~\textbf{default}~\upsilon_d$, according to E-ASSERTCONSTRAINT and E-ASSERT, it holds the progress property as well.
            \item For the expression $\textbf{concretize}~e~\textbf{with}~\upsilon_c$, if sub-expression $e$ is not a value, according to the hypothesis, there exists an expression $e'$ such that  $\vdash\left\langle\Sigma, \Delta, e\right\rangle\rightarrow\left\langle\Sigma',\Delta',e'\right\rangle$. According to E-CONCRETIZEEXP, it holds the \textbf{progress} property. On the contrary, if sub-expression $e$ is a value, then a MODEL will be built to model the constraints, and it can be reduced to a concrete value $c$ that satisfies the model or an \textbf{error} will be generated while the model cannot be satisfied according to E-CONCRETIZESAT and E-CONCRETIZEUNSAT. Therefore, we can conclude the expression $\textbf{concretize}~e~\textbf{with}~\upsilon_c$ holds the property as well.
            \item For the expression $\textbf{let}~x:\tau=e_1~\textbf{in}~e_2$ and $\textbf{let rec}~f:\tau=e_1~\textbf{in}~e_2$, expressions $e_1$ and $e_2$ are composed by one ore more above expressions. Thus, it holds the property accordingly.
        \end{itemize}
    \end{proof}
    
    \begin{theorem}
        $\mathrm{(Preservision).}$ If $\Gamma\vdash e:\tau\delta$ and $e\rightarrow e'$, then $\Gamma\vdash e':\tau\delta$. 
    \end{theorem}
    \begin{proof}
        According to the static semantics \ref{static-sem-lambdaj}, we can proof that $\lambdaJ$ program is type-preserved by structral induction over the syntax of $\lambdaJ$. According to T-VAR, T-INT, T-BOOL, T-UNIT, T-CONTEXT, we know the simple expressions are all type-preserved. Next we will discuss the $operation$, $condition$, $\lambda~ abstraction$, $application$, $let$, $assert$, $defer$ and $concretize$ expressions respectively. At the beginning, by the typing rules from Figure \ref{static-sem-lambdaj}, we conclude that all the $\delta$ value is the same for both sides except for the T-CONCRETIZE in which, however, the type is also preserved for it only cast the symbolic type to the corresponding concrete type. Therefore, we will not discuss the $\delta$ type in the following proof. In addition, by the hypothesis, all the sub-expressions are well-typed while proof the specific expression.
        \begin{itemize}
            \item For the operation expression $e_1~(op)~e_2$, assume that expression $e_1$ is with the type $\tau_1$ and expression $e_2$ is with the type $\tau_2$, according to T-OP there must be a type $\tau$ that is the common super type of $e_1$ and $e_2$, such that the expression $e_1~(op)~e_2$ is with the type $\tau$. According to E-OP, E-OP1 and E-OP2, after one step evaluation, the expression $e_1$ will be some $e'_1$ with the type $\tau'_1$, such that $\tau'_1<:\tau_1$, or the expression $e_2$  will be reduced to some $e'_2$ with the type $\tau'_2$ and $\tau'_2<:\tau_2$, assume that the evaluated expression is with the type $\tau'$, according to subtyping, we know $\tau'<:\tau$, which indicates that the type is preserved.
            \item For the conditional expression $\textbf{if}~e_1~\textbf{then}~e_t~\textbf{else}~e_f$, assume expressions $e_t$ and $e_f$ are with the type $\tau_1$ and $\tau_2$ respectively. According to T-CONDC and T-CONDSYM, if the expression $e_1$ is with the symbolic type, $\textbf{if}~e_1~\textbf{then}~e_t~\textbf{else}~e_f$ must be with some type $\tau$ which is the common super type of $\tau_1$ and $\tau_2$. Then according to E-CONDSYMT, after one step evaluation $e_t$ will be reduced to some $e'_t$ with the type $\tau'_1$. According to the hypothesis, $\tau'_1<:\tau_1$. Therefore the type $\tau$ is the common super type of $\tau'_1$ and $\tau_2$ as well. And the E-CONDSYMF is the same. In addition, if the expression $e_1$ is with the concrete type, there will be only one branch being taken, either $\tau_1$ or $\tau_2$, either of which holds the subtyping relation  naturally. Consequently, the conditional expression is type-preserved.
            \item For the $\lambda$ abstraction expression $\lambda x:\tau.e$, according to E-APPLAMBDA, the type of the expression will not change and it is type-preserved naturally.
            \item For the application expression $e_1~e_2$, assume the type of $e_1$ and $e_2$ are $\tau_1\rightarrow\tau_2$ and $\tau'_1$ respectively. In addition, $\tau'_1<:\tau_1$, and according to T-APP, the type of application expression is $\tau_2$. Then according to E-APP1 and E-APP2, the evaluated expression will preserve the expression type due to the hypothesis that the sub-expressions $e_1$ and $e_2$ preserve the corresponding type respectively.
            \item Similarly for the expression $\textbf{let rec}~f:\tau=e_1~\textbf{in}~e_2$, $\textbf{assert}~e$, $\textbf{defer}~x:\tau\{e\}~\textbf{default}~\upsilon_d$ and $\textbf{concretize}~e~\textbf{with}~\upsilon_c$.
        \end{itemize}
        
    \end{proof}